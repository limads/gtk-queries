use libloading::{Library, Symbol};
use super::parser::*;
use crate::tables::{table::*, column::*};
use ::queries::*;
use std::convert::{TryFrom, TryInto};
use super::loader::FunctionErr;

const EMPTY : Option<()> = None;

const EMPTY_VEC : Option<Vec<()>> = None;

fn call<'a, A,B,C,D,E,R>(
    lib : &'a Library,
    f_name : &[u8],
    a : A,
    b : Option<B>,
    c : Option<C>,
    d : Option<D>,
    e : Option<E>
) -> Result<R, String>
    where
        A : 'a,
        B : 'a,
        C : 'a,
        D : 'a,
        E : 'a,
        R : 'a
{
    unsafe {
        match (b, c, d, e) {
            (None, None, None, None) => {
                let f : Symbol<'a, unsafe extern fn(A)->Result<R,String>> =
                    lib.get(f_name).map_err(|e| format!("{}",e))?;
                f(a)
            },
            (Some(b), None, None, None) => {
                let f : Symbol<'a, unsafe extern fn(A, B)->Result<R,String>> =
                    lib.get(f_name).map_err(|e| format!("{}",e))?;
                f(a,b)
            },
            (Some(b), Some(c), None, None) => {
                let f : Symbol<'a, unsafe extern fn(A,B,C)->Result<R,String>> =
                    lib.get(f_name).map_err(|e| format!("{}",e))?;
                f(a, b, c)
            },
            (Some(b), Some(c), Some(d), None) => {
                let f : Symbol<'a, unsafe extern fn(A,B,C,D)->Result<R,String>> =
                    lib.get(f_name).map_err(|e| format!("{}",e))?;
                f(a, b, c, d)
            },
            (Some(b), Some(c), Some(d), Some(e)) => {
                let f : Symbol<'a, unsafe extern fn(A,B,C,D,E)->Result<R,String>> =
                    lib.get(f_name).map_err(|e| format!("{}",e))?;
                f(a, b, c, d, e)
            },
            _ => unimplemented!()
        }
    }
}

fn dispatch_ret<A, B, C, D, E, R1, R2, R3, R4, R5>(
    lib : &Library,
    f_name : &[u8],
    a : A,
    b : Option<B>,
    c : Option<C>,
    d : Option<D>,
    e : Option<E>,
    ret_ix : usize,
    var_ret : bool,
    rets : &[SqlType]
) -> Result<Vec<Column>, String>
where
    Column : From<Vec<R1>> + From<Vec<R2>> + From<Vec<R3>> + From<Vec<R4>> + From<Vec<R5>>
{
    match rets.get(ret_ix) {
        Some(SqlType::I32) => match ret_ix {
            0 => dispatch_ret::<A,B,C,D,E,i32,(),(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            1 => dispatch_ret::<A,B,C,D,E,R1, i32,(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            2 => dispatch_ret::<A,B,C,D,E,R1, R2, i32, (), ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            3 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, i32, ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            4 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, R4, i32>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            _ => unimplemented!()
        },
        Some(SqlType::I64) => match ret_ix {
            0 => dispatch_ret::<A,B,C,D,E,i64,(),(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            1 => dispatch_ret::<A,B,C,D,E,R1, i64,(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            2 => dispatch_ret::<A,B,C,D,E,R1, R2, i64, (), ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            3 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, i64, ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            4 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, R4, i64>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            _ => unimplemented!()
        },
        Some(SqlType::F32) => match ret_ix {
            0 => dispatch_ret::<A,B,C,D,E,f32,(),(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            1 => dispatch_ret::<A,B,C,D,E,R1, f32,(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            2 => dispatch_ret::<A,B,C,D,E,R1, R2, f32, (), ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            3 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, f32, ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            4 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, R4, f32>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            _ => unimplemented!()
        }
        Some(SqlType::F64) => match ret_ix {
            0 => dispatch_ret::<A,B,C,D,E,f64,(),(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            1 => dispatch_ret::<A,B,C,D,E,R1, f64,(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            2 => dispatch_ret::<A,B,C,D,E,R1, R2, f64, (), ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            3 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, f64, ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            4 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, R4, f64>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            _ => unimplemented!()
        },
        Some(SqlType::String) => match ret_ix {
            0 => dispatch_ret::<A,B,C,D,E,String,(),(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            1 => dispatch_ret::<A,B,C,D,E,R1, String,(),(),()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            2 => dispatch_ret::<A,B,C,D,E,R1, R2, String, (), ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            3 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, String, ()>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            4 => dispatch_ret::<A,B,C,D,E,R1, R2, R3, R4, String>(lib, f_name, a, b, c, d, e, ret_ix+1, var_ret, rets),
            _ => unimplemented!()
        },
        None => {
            match ret_ix {
                1 => {
                    match var_ret {
                        true => {
                            let ans = call::<A, B, C, D, E, Vec<Vec<R1>>>(lib, f_name, a, b, c, d, e)?;
                            Ok(ans.into_iter().map(|v| v.into()).collect())
                        }
                        false => {
                            let ans = call::<A, B, C, D, E, Vec<R1>>(lib, f_name, a, b, c, d, e)?;
                            Ok(vec![ans.into()])
                        }
                    }
                },
                2 => {
                    match var_ret {
                        true => {
                            let (fix, var) =
                                call::<A, B, C, D, E, (Vec<R1>,Vec<Vec<R2>>)>(lib, f_name, a, b, c, d, e)?;
                            let mut cols = vec![fix.into()];
                            cols.extend(var.into_iter().map(|v| v.into()));
                            Ok(cols)
                        }
                        false => {
                            let fix = call::<A, B, C, D, E, (Vec<R1>,Vec<R2>)>(lib, f_name, a, b, c, d, e)?;
                            Ok(vec![fix.0.into(), fix.1.into()])
                        }
                    }
                },
                3 => {
                    match var_ret {
                        true => {
                            let (fix1, fix2, var) =
                                call::<A, B, C, D, E, (Vec<R1>,Vec<R2>,Vec<Vec<R3>>)>(lib, f_name, a, b, c, d, e)?;
                            let mut cols = vec![fix1.into(), fix2.into()];
                            cols.extend(var.into_iter().map(|v| v.into()));
                            Ok(cols)
                        }
                        false => {
                            let fix = call::<A, B, C, D, E, (Vec<R1>,Vec<R2>,Vec<R3>)>(lib, f_name, a, b, c, d, e)?;
                            Ok(vec![fix.0.into(), fix.1.into(), fix.2.into()])
                        }
                    }
                },
                4 => {
                    match var_ret {
                        true => {
                            let (fix1, fix2, fix3, var) =
                                call::<A, B, C, D, E, (Vec<R1>,Vec<R2>,Vec<R3>,Vec<Vec<R4>>)>(lib, f_name, a, b, c, d, e)?;
                            let mut cols = vec![fix1.into(), fix2.into(), fix3.into()];
                            cols.extend(var.into_iter().map(|v| v.into()));
                            Ok(cols)
                        }
                        false => {
                            let fix = call::<A, B, C, D, E, (Vec<R1>,Vec<R2>,Vec<R3>,Vec<R4>)>(lib, f_name, a, b, c, d, e)?;
                            Ok(vec![fix.0.into(), fix.1.into(), fix.2.into(), fix.3.into()])
                        }
                    }
                },
                5 => {
                    match var_ret {
                        true => {
                            let (fix1, fix2, fix3, fix4, var) =
                                call::<A, B, C, D, E, (Vec<R1>,Vec<R2>,Vec<R3>,Vec<R4>,Vec<Vec<R5>>)>(lib, f_name, a, b, c, d, e)?;
                            let mut cols = vec![fix1.into(), fix2.into(), fix3.into(), fix4.into()];
                            cols.extend(var.into_iter().map(|v| v.into()));
                            Ok(cols)
                        }
                        false => {
                            let fix = call::<A, B, C, D, E, (Vec<R1>,Vec<R2>,Vec<R3>,Vec<R4>, Vec<R5>)>(lib, f_name, a, b, c, d, e)?;
                            Ok(vec![fix.0.into(), fix.1.into(), fix.2.into(), fix.3.into(), fix.4.into()])
                        }
                    }
                },
                _ => unimplemented!()
            }
        }
    }
}

fn take_variadic_arg<V>(
    last_fix : V,
    fix_ix : usize,
    rem_args : Vec<Column>
) -> Result<Vec<V>, FunctionErr>
    where
        // F : Into<Vec<V>>,
        Column : TryInto<V>
{
    let mut var_args = vec![last_fix];
    let mut var_ix = fix_ix;
    while rem_args.len() > 0 {
        let res_v : Result<V,_> = rem_args.remove(0).try_into();
        match res_v {
            Ok(v) => var_args.push(v),
            Err(_) => { return Err(FunctionErr::TypeMismatch(var_ix)); }
        }
        var_ix += 1;
    }
    Ok(var_args)
}

pub fn dispatch_arg<A, B, C, D, E>(
    lib : &Library,
    f_name : &[u8],
    a : A,
    b : B,
    c : C,
    d : D,
    e : E,
    arg_ix : usize,
    cols : Vec<Column>,
    f : &Function
) -> Result<Vec<Column>, FunctionErr>
    where
        Column : TryInto<A> + TryInto<B> + TryInto<C> + TryInto<D> + TryInto<E>
{
    match f.args.get(arg_ix) {
        Some(SqlType::I32) => {
            let res_v : Result<Vec<i32>, _> = cols[0].try_into();
            match res_v {
                Ok(v) => match arg_ix {
                    0 => dispatch_arg(&lib, f.name.as_bytes(), v, (), (), (), (), arg_ix+1, cols, &f),
                    1 => dispatch_arg(&lib, f.name.as_bytes(), a, v, (), (), (), arg_ix+1, cols, &f),
                    2 => dispatch_arg(&lib, f.name.as_bytes(), a, b, v, (), (), arg_ix+1, cols, &f),
                    3 => dispatch_arg(&lib, f.name.as_bytes(), a, b, c, v, (), arg_ix+1, cols, &f),
                    4 => dispatch_arg(&lib, f.name.as_bytes(), a, b, c, d, v, arg_ix+1, cols, &f),
                },
                Err(_) => return Err(FunctionErr::TypeMismatch(arg_ix))
            }
        },
        Some(SqlType::I64) => {
            let res_v : Result<Vec<i64>, _> = cols[0].try_into();
            match res_v {
                Ok(v) => {
                    unimplemented!()
                },
                Err(_) => return Err(FunctionErr::TypeMismatch(arg_ix)),
            }
        },
        Some(SqlType::F32) => {
            let res_v : Result<Vec<f32>, _> = cols[0].try_into();
            match res_v {
                Ok(v) => {
                    unimplemented!()
                },
                Err(_) => return Err(FunctionErr::TypeMismatch(arg_ix)),
            }
        },
        Some(SqlType::F64) => {
            let res_v : Result<Vec<f64>, _> = cols[0].try_into();
            match res_v {
                Ok(v) => {
                    unimplemented!()
                },
                Err(_) => return Err(FunctionErr::TypeMismatch(arg_ix)),
            }
        },
        None => {
            match arg_ix {
                1 => match f.var_arg {
                    true => {
                        let mut var_a = take_variadic_arg(a, 1, cols)?;
                        dispatch_ret::<_,_,_,_,_,(),(),(),(),()>(&lib, f_name, var_a, EMPTY, EMPTY, EMPTY, EMPTY, 0, f.var_ret, &f.ret)
                            .map_err(|msg| FunctionErr::UserErr(msg))
                    },
                    false => dispatch_ret::<_,_,_,_,_,(),(),(),(),()>(&lib, f_name, a, EMPTY, EMPTY, EMPTY, EMPTY,0,f.var_ret,&f.ret)
                        .map_err(|msg| FunctionErr::UserErr(msg)),
                },
                2 => unimplemented!(),
                3 => unimplemented!(),
                4 => unimplemented!(),
                5 => unimplemented!(),
                _ => unimplemented!()
            }
        }
    }
}

// Actual call status will be:
// dispatch_ret::<(), (), (), (), (), (), (), (), (), ()>(lib, tbl, f_name, arg_types, rets, 0, 0)

/*fn call_single_arg<'a, A, R1, R2, R3, R4, R5>(
    lib : &'a Library
    name : &'a str
    a : A,
    n_ret : usize,
    r1 : &mut R1,
    r2 : &mut R2,
    r3 : &mut R3,
    r4 : &mut R4,
    r5 : &mut R5
) {
    match n_ret {
        1 => {
            let f : OneArgSingle<'a, A, R1> = lib.get(name).unwrap();
            let ans = f(a);
            *r1 = ans;
        },
        2 => {
            let f : OneArgTuple<'a, A, R1, R2> = lib.get(name).unwrap();
            let ans = f(a);
            *r1 = ans.0;
            *r2 = ans.1;
        },
        3 => {
            unimplemeneted!()
        },
        4 => {
            unimplemeneted!()
        },
        5 => {
            unimplemeneted!()
        },
        _ => panic!("Function can have at most five return types")
    }
}

fn call_any<A, B, C, D, E, R1, R2, R3, R4, R5>(
    lib : &'a Library,
    name : &'a str,
    args : (A, B, C, D, E),
    ret : (&mut R1, &mut R2, &mut R3, &mut R4, &mut R5),
    n_args : usize,
    n_ret : usize
) -> (R1, R2, R3, R4, R5) {
    match n_args {
        1 => call_single_arg(lib, name, args.0, n_ret, r1, r2, r3, r4, r5),
        2 => unimplemented!(),
        3 => unimplemented!(),
        4 => unimplemented!(),
        5 => unimplemented!(),
        _ => panic!("Function can have at most five arguments")
    }
}

fn dispatch_ret<A, B, C, D, E, R1, R2, R3, R4, R5>(
    lib : &'a Libray,
    name : &'a str,
    arg_types : &[SqlArgument],
    args : Vec<Column>,
    ret : Vec<&mut Column>,
    n_args : usize,
    n_ret : usize
) {
    match args.len() {
        0 => {
            match ret.len() {
                0 => {
                    call_any::<A, B, C, D, E, R1, R2, R3, R4, R5>(lib, name, args, ret)
                },
                1 => {
                    call_any::<A, B, C, D, E, R1, R2, R3, R4, ()>(lib, name, args, ret)
                },
                2 => {
                    call_any::<A, B, C, D, E, R1, R2, R3, (), ()>(lib, name, args, ret)
                },
                3 => {
                    call_any::<A, B, C, D, E, R1, R2, (), (), ()>(lib, name, args, ret)
                },
                4 => {
                    call_any::<A, B, C, D, E, R1, (), (), (), ()>(lib, name, args, ret)
                },
                5 => {
                    call_any::<A, B, C, D, E, R1, R2, R3, R4, ()>(lib, name, args, ret)
                },
                "Integer" => call_any::<A, B, i32>(),
                "Real" => call_any::<A, B, f64>(),
                "Text" => call_any::<A, B, String>(),
                "Bytes" => call_any::<A, B, Vec<u8>>(),
                _ => unimplemented!()
            }
        },
        1 => {
            match args[1] {
                "Integer" => call_tuple::<A, i32, R>(&[], ret),
                "Real" => call_tuple::<A, f64, R>(&[], ret),
                "Text" => call_tuple::<A, String, R>(&[], ret),
                "Bytes" => call_tuple::<A, Vec<u8>, R>(&[], ret),
                _ => unimplemented!()
            }
        },
        2 => {
            match args[2] {
                "Integer" => call_tuple::<i32, B, R>(&args[0..1], ret),
                "Real" => call_tuple::<f64, B, R>(&args[0..1], ret),
                "Text" => call_tuple::<String, B, R>(&args[0..1], ret),
                "Bytes" => call_tuple::<Vec<u8>, B, R>(&args[0..1], ret),
                _ => unimplemented!()
            }
        },
        _ => unimplemented!()
    }
}*/

